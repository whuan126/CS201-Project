/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// getMnemonic - This method is automatically generated by tablegen
/// from the instruction set description.
std::pair<const char *, uint64_t> XCoreInstPrinter::getMnemonic(const MCInst *MI) {

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif
  static const char AsmStrs[] = {
  /* 0 */ "ldap r11, \0"
  /* 11 */ "getsr r11, \0"
  /* 23 */ "set cp, \0"
  /* 32 */ "set dp, \0"
  /* 41 */ "set sp, \0"
  /* 50 */ "crc32 \0"
  /* 57 */ "lda16 \0"
  /* 64 */ "st16 \0"
  /* 70 */ "crc8 \0"
  /* 76 */ "st8 \0"
  /* 81 */ "# LDAWFI \0"
  /* 91 */ "# LDWFI \0"
  /* 100 */ "# STWFI \0"
  /* 109 */ "# EH_RETURN \0"
  /* 122 */ "# ADJCALLSTACKDOWN \0"
  /* 142 */ "# ADJCALLSTACKUP \0"
  /* 160 */ "# FRAME_TO_ARGS_OFFSET \0"
  /* 184 */ "bla \0"
  /* 189 */ "lsub \0"
  /* 195 */ "ldc \0"
  /* 200 */ "ladd \0"
  /* 206 */ "and \0"
  /* 211 */ "getd \0"
  /* 217 */ "bf \0"
  /* 221 */ "eef \0"
  /* 226 */ "waitef \0"
  /* 234 */ "ecallf \0"
  /* 242 */ "neg \0"
  /* 247 */ "dgetreg \0"
  /* 256 */ "peek \0"
  /* 262 */ "mkmsk \0"
  /* 269 */ "bl \0"
  /* 273 */ "testlcl \0"
  /* 282 */ "shl \0"
  /* 287 */ "kcall \0"
  /* 294 */ "lmul \0"
  /* 300 */ "endin \0"
  /* 307 */ "getn \0"
  /* 313 */ "extdp \0"
  /* 320 */ "retsp \0"
  /* 327 */ "kentsp \0"
  /* 335 */ "krestsp \0"
  /* 344 */ "extsp \0"
  /* 351 */ "eq \0"
  /* 355 */ "ashr \0"
  /* 361 */ "inshr \0"
  /* 368 */ "xor \0"
  /* 373 */ "clrsr \0"
  /* 380 */ "setsr \0"
  /* 387 */ "getr \0"
  /* 393 */ "ld16s \0"
  /* 400 */ "maccs \0"
  /* 407 */ "rems \0"
  /* 413 */ "lss \0"
  /* 418 */ "getts \0"
  /* 425 */ "divs \0"
  /* 431 */ "blat \0"
  /* 437 */ "bt \0"
  /* 441 */ "inct \0"
  /* 447 */ "testct \0"
  /* 455 */ "testwct \0"
  /* 464 */ "eet \0"
  /* 469 */ "get \0"
  /* 474 */ "waitet \0"
  /* 482 */ "ecallt \0"
  /* 490 */ "int \0"
  /* 495 */ "andnot \0"
  /* 503 */ "getst \0"
  /* 510 */ "sext \0"
  /* 516 */ "zext \0"
  /* 522 */ "ld8u \0"
  /* 528 */ "bau \0"
  /* 533 */ "bu \0"
  /* 537 */ "maccu \0"
  /* 544 */ "remu \0"
  /* 550 */ "bru \0"
  /* 555 */ "lsu \0"
  /* 560 */ "ldivu \0"
  /* 567 */ "byterev \0"
  /* 576 */ "bitrev \0"
  /* 584 */ "ldaw \0"
  /* 590 */ "ldw \0"
  /* 595 */ "inpw \0"
  /* 601 */ "stw \0"
  /* 606 */ "clz \0"
  /* 611 */ "# SELECT_CC PSEUDO!\0"
  /* 631 */ "# XRay Function Patchable RET.\0"
  /* 662 */ "# XRay Typed Event Log.\0"
  /* 686 */ "# XRay Custom Event Log.\0"
  /* 711 */ "# XRay Function Enter.\0"
  /* 734 */ "# XRay Tail Call Exit.\0"
  /* 757 */ "# XRay Function Exit.\0"
  /* 779 */ "set kep, r11\0"
  /* 792 */ "LIFETIME_END\0"
  /* 805 */ "PSEUDO_PROBE\0"
  /* 818 */ "BUNDLE\0"
  /* 825 */ "DBG_VALUE\0"
  /* 835 */ "DBG_INSTR_REF\0"
  /* 849 */ "DBG_LABEL\0"
  /* 859 */ "#MEMBARRIER\0"
  /* 871 */ "LIFETIME_START\0"
  /* 886 */ "ldaw r11, cp[\0"
  /* 900 */ "ldw r11, cp[\0"
  /* 913 */ "bla cp[\0"
  /* 921 */ "msync res[\0"
  /* 932 */ "setpsc res[\0"
  /* 944 */ "setc res[\0"
  /* 954 */ "setd res[\0"
  /* 964 */ "setclk res[\0"
  /* 976 */ "mjoin res[\0"
  /* 987 */ "setn res[\0"
  /* 997 */ "syncr res[\0"
  /* 1008 */ "freer res[\0"
  /* 1019 */ "outshr res[\0"
  /* 1031 */ "chkct res[\0"
  /* 1042 */ "outct res[\0"
  /* 1053 */ "clrpt res[\0"
  /* 1064 */ "setpt res[\0"
  /* 1075 */ "outt res[\0"
  /* 1085 */ "out res[\0"
  /* 1094 */ "edu res[\0"
  /* 1103 */ "eeu res[\0"
  /* 1112 */ "setev res[\0"
  /* 1123 */ "setv res[\0"
  /* 1133 */ "outpw res[\0"
  /* 1144 */ "settw res[\0"
  /* 1155 */ "setrdy res[\0"
  /* 1167 */ "set ps[\0"
  /* 1175 */ "set t[\0"
  /* 1182 */ "init t[\0"
  /* 1190 */ "start t[\0"
  /* 1199 */ "ldw spc, sp[1]\0"
  /* 1214 */ "stw spc, sp[1]\0"
  /* 1229 */ "ldw ssr, sp[2]\0"
  /* 1244 */ "stw ssr, sp[2]\0"
  /* 1259 */ "ldw sed, sp[3]\0"
  /* 1274 */ "stw sed, sp[3]\0"
  /* 1289 */ "ldw et, sp[4]\0"
  /* 1303 */ "stw et, sp[4]\0"
  /* 1317 */ "ssync\0"
  /* 1323 */ "get r11, ed\0"
  /* 1335 */ "get r11, id\0"
  /* 1347 */ "clre\0"
  /* 1352 */ "# FEntry call\0"
  /* 1366 */ "dcall\0"
  /* 1372 */ "get r11, kep\0"
  /* 1385 */ "get r11, ksp\0"
  /* 1398 */ "dentsp\0"
  /* 1405 */ "drestsp\0"
  /* 1413 */ "tsetmr r\0"
  /* 1422 */ "get r11, et\0"
  /* 1434 */ "freet\0"
  /* 1440 */ "dret\0"
  /* 1445 */ "kret\0"
  /* 1450 */ "waiteu\0"
};
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

  static const uint32_t OpInfo0[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// INLINEASM_BR
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// ANNOTATION_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    826U,	// DBG_VALUE
    836U,	// DBG_INSTR_REF
    850U,	// DBG_LABEL
    0U,	// REG_SEQUENCE
    0U,	// COPY
    819U,	// BUNDLE
    872U,	// LIFETIME_START
    793U,	// LIFETIME_END
    806U,	// PSEUDO_PROBE
    0U,	// STACKMAP
    1353U,	// FENTRY_CALL
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// PREALLOCATED_SETUP
    0U,	// PREALLOCATED_ARG
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_OP
    0U,	// PATCHABLE_OP
    712U,	// PATCHABLE_FUNCTION_ENTER
    632U,	// PATCHABLE_RET
    758U,	// PATCHABLE_FUNCTION_EXIT
    735U,	// PATCHABLE_TAIL_CALL
    687U,	// PATCHABLE_EVENT_CALL
    663U,	// PATCHABLE_TYPED_EVENT_CALL
    0U,	// ICALL_BRANCH_FUNNEL
    0U,	// G_ADD
    0U,	// G_SUB
    0U,	// G_MUL
    0U,	// G_SDIV
    0U,	// G_UDIV
    0U,	// G_SREM
    0U,	// G_UREM
    0U,	// G_AND
    0U,	// G_OR
    0U,	// G_XOR
    0U,	// G_IMPLICIT_DEF
    0U,	// G_PHI
    0U,	// G_FRAME_INDEX
    0U,	// G_GLOBAL_VALUE
    0U,	// G_EXTRACT
    0U,	// G_UNMERGE_VALUES
    0U,	// G_INSERT
    0U,	// G_MERGE_VALUES
    0U,	// G_BUILD_VECTOR
    0U,	// G_BUILD_VECTOR_TRUNC
    0U,	// G_CONCAT_VECTORS
    0U,	// G_PTRTOINT
    0U,	// G_INTTOPTR
    0U,	// G_BITCAST
    0U,	// G_FREEZE
    0U,	// G_INTRINSIC_TRUNC
    0U,	// G_INTRINSIC_ROUND
    0U,	// G_INTRINSIC_LRINT
    0U,	// G_INTRINSIC_ROUNDEVEN
    0U,	// G_READCYCLECOUNTER
    0U,	// G_LOAD
    0U,	// G_SEXTLOAD
    0U,	// G_ZEXTLOAD
    0U,	// G_INDEXED_LOAD
    0U,	// G_INDEXED_SEXTLOAD
    0U,	// G_INDEXED_ZEXTLOAD
    0U,	// G_STORE
    0U,	// G_INDEXED_STORE
    0U,	// G_ATOMIC_CMPXCHG_WITH_SUCCESS
    0U,	// G_ATOMIC_CMPXCHG
    0U,	// G_ATOMICRMW_XCHG
    0U,	// G_ATOMICRMW_ADD
    0U,	// G_ATOMICRMW_SUB
    0U,	// G_ATOMICRMW_AND
    0U,	// G_ATOMICRMW_NAND
    0U,	// G_ATOMICRMW_OR
    0U,	// G_ATOMICRMW_XOR
    0U,	// G_ATOMICRMW_MAX
    0U,	// G_ATOMICRMW_MIN
    0U,	// G_ATOMICRMW_UMAX
    0U,	// G_ATOMICRMW_UMIN
    0U,	// G_ATOMICRMW_FADD
    0U,	// G_ATOMICRMW_FSUB
    0U,	// G_FENCE
    0U,	// G_BRCOND
    0U,	// G_BRINDIRECT
    0U,	// G_INTRINSIC
    0U,	// G_INTRINSIC_W_SIDE_EFFECTS
    0U,	// G_ANYEXT
    0U,	// G_TRUNC
    0U,	// G_CONSTANT
    0U,	// G_FCONSTANT
    0U,	// G_VASTART
    0U,	// G_VAARG
    0U,	// G_SEXT
    0U,	// G_SEXT_INREG
    0U,	// G_ZEXT
    0U,	// G_SHL
    0U,	// G_LSHR
    0U,	// G_ASHR
    0U,	// G_FSHL
    0U,	// G_FSHR
    0U,	// G_ICMP
    0U,	// G_FCMP
    0U,	// G_SELECT
    0U,	// G_UADDO
    0U,	// G_UADDE
    0U,	// G_USUBO
    0U,	// G_USUBE
    0U,	// G_SADDO
    0U,	// G_SADDE
    0U,	// G_SSUBO
    0U,	// G_SSUBE
    0U,	// G_UMULO
    0U,	// G_SMULO
    0U,	// G_UMULH
    0U,	// G_SMULH
    0U,	// G_UADDSAT
    0U,	// G_SADDSAT
    0U,	// G_USUBSAT
    0U,	// G_SSUBSAT
    0U,	// G_USHLSAT
    0U,	// G_SSHLSAT
    0U,	// G_SMULFIX
    0U,	// G_UMULFIX
    0U,	// G_SMULFIXSAT
    0U,	// G_UMULFIXSAT
    0U,	// G_SDIVFIX
    0U,	// G_UDIVFIX
    0U,	// G_SDIVFIXSAT
    0U,	// G_UDIVFIXSAT
    0U,	// G_FADD
    0U,	// G_FSUB
    0U,	// G_FMUL
    0U,	// G_FMA
    0U,	// G_FMAD
    0U,	// G_FDIV
    0U,	// G_FREM
    0U,	// G_FPOW
    0U,	// G_FPOWI
    0U,	// G_FEXP
    0U,	// G_FEXP2
    0U,	// G_FLOG
    0U,	// G_FLOG2
    0U,	// G_FLOG10
    0U,	// G_FNEG
    0U,	// G_FPEXT
    0U,	// G_FPTRUNC
    0U,	// G_FPTOSI
    0U,	// G_FPTOUI
    0U,	// G_SITOFP
    0U,	// G_UITOFP
    0U,	// G_FABS
    0U,	// G_FCOPYSIGN
    0U,	// G_FCANONICALIZE
    0U,	// G_FMINNUM
    0U,	// G_FMAXNUM
    0U,	// G_FMINNUM_IEEE
    0U,	// G_FMAXNUM_IEEE
    0U,	// G_FMINIMUM
    0U,	// G_FMAXIMUM
    0U,	// G_PTR_ADD
    0U,	// G_PTRMASK
    0U,	// G_SMIN
    0U,	// G_SMAX
    0U,	// G_UMIN
    0U,	// G_UMAX
    0U,	// G_ABS
    0U,	// G_BR
    0U,	// G_BRJT
    0U,	// G_INSERT_VECTOR_ELT
    0U,	// G_EXTRACT_VECTOR_ELT
    0U,	// G_SHUFFLE_VECTOR
    0U,	// G_CTTZ
    0U,	// G_CTTZ_ZERO_UNDEF
    0U,	// G_CTLZ
    0U,	// G_CTLZ_ZERO_UNDEF
    0U,	// G_CTPOP
    0U,	// G_BSWAP
    0U,	// G_BITREVERSE
    0U,	// G_FCEIL
    0U,	// G_FCOS
    0U,	// G_FSIN
    0U,	// G_FSQRT
    0U,	// G_FFLOOR
    0U,	// G_FRINT
    0U,	// G_FNEARBYINT
    0U,	// G_ADDRSPACE_CAST
    0U,	// G_BLOCK_ADDR
    0U,	// G_JUMP_TABLE
    0U,	// G_DYN_STACKALLOC
    0U,	// G_STRICT_FADD
    0U,	// G_STRICT_FSUB
    0U,	// G_STRICT_FMUL
    0U,	// G_STRICT_FDIV
    0U,	// G_STRICT_FREM
    0U,	// G_STRICT_FMA
    0U,	// G_STRICT_FSQRT
    0U,	// G_READ_REGISTER
    0U,	// G_WRITE_REGISTER
    0U,	// G_MEMCPY
    0U,	// G_MEMMOVE
    0U,	// G_MEMSET
    0U,	// G_VECREDUCE_SEQ_FADD
    0U,	// G_VECREDUCE_SEQ_FMUL
    0U,	// G_VECREDUCE_FADD
    0U,	// G_VECREDUCE_FMUL
    0U,	// G_VECREDUCE_FMAX
    0U,	// G_VECREDUCE_FMIN
    0U,	// G_VECREDUCE_ADD
    0U,	// G_VECREDUCE_MUL
    0U,	// G_VECREDUCE_AND
    0U,	// G_VECREDUCE_OR
    0U,	// G_VECREDUCE_XOR
    0U,	// G_VECREDUCE_SMAX
    0U,	// G_VECREDUCE_SMIN
    0U,	// G_VECREDUCE_UMAX
    0U,	// G_VECREDUCE_UMIN
    2171U,	// ADJCALLSTACKDOWN
    10383U,	// ADJCALLSTACKUP
    283175U,	// BR_JT
    545319U,	// BR_JT32
    2158U,	// EH_RETURN
    10401U,	// FRAME_TO_ARGS_OFFSET
    860U,	// Int_MemBarrier
    2130U,	// LDAWFI
    2140U,	// LDWFI
    612U,	// SELECT_CC
    2149U,	// STWFI
    2099402U,	// ADD_2rus
    2099402U,	// ADD_3r
    788976U,	// ANDNOT_2r
    2099407U,	// AND_3r
    2099556U,	// ASHR_l2rus
    2099556U,	// ASHR_l3r
    10769U,	// BAU_1r
    2625U,	// BITREV_l2r
    27538U,	// BLACP_lu10
    27538U,	// BLACP_u10
    10672U,	// BLAT_lu6
    10672U,	// BLAT_u6
    10425U,	// BLA_1r
    10510U,	// BLRB_lu10
    10510U,	// BLRB_u10
    10510U,	// BLRF_lu10
    10510U,	// BLRF_u10
    2266U,	// BRBF_lru6
    2266U,	// BRBF_ru6
    2486U,	// BRBT_lru6
    2486U,	// BRBT_ru6
    10774U,	// BRBU_lu6
    10774U,	// BRBU_u6
    2266U,	// BRFF_lru6
    2266U,	// BRFF_ru6
    2486U,	// BRFT_lru6
    2486U,	// BRFT_ru6
    10774U,	// BRFU_lu6
    10774U,	// BRFU_u6
    10791U,	// BRU_1r
    2616U,	// BYTEREV_l2r
    35848U,	// CHKCT_2r
    35848U,	// CHKCT_rus
    1348U,	// CLRE_0R
    27678U,	// CLRPT_1R
    10614U,	// CLRSR_branch_lu6
    10614U,	// CLRSR_branch_u6
    10614U,	// CLRSR_lu6
    10614U,	// CLRSR_u6
    2655U,	// CLZ_l2r
    5247047U,	// CRC8_l4r
    19662899U,	// CRC_l3r
    1367U,	// DCALL_0R
    1399U,	// DENTSP_0R
    10488U,	// DGETREG_1r
    2099626U,	// DIVS_l3r
    2099762U,	// DIVU_l3r
    1406U,	// DRESTSP_0R
    1441U,	// DRET_0R
    10475U,	// ECALLF_1r
    10723U,	// ECALLT_1r
    27719U,	// EDU_1r
    6334686U,	// EEF_2r
    6334929U,	// EET_2r
    27728U,	// EEU_1r
    6334765U,	// ENDIN_2r
    10569U,	// ENTSP_lu6
    10569U,	// ENTSP_u6
    2099552U,	// EQ_2rus
    2099552U,	// EQ_3r
    10554U,	// EXTDP_lu6
    10554U,	// EXTDP_u6
    10585U,	// EXTSP_lu6
    10585U,	// EXTSP_u6
    27633U,	// FREER_1r
    1435U,	// FREET_0R
    6334676U,	// GETD_l2r
    1324U,	// GETED_0R
    1423U,	// GETET_0R
    1336U,	// GETID_0R
    1373U,	// GETKEP_0R
    1386U,	// GETKSP_0R
    6334772U,	// GETN_l2r
    51670U,	// GETPS_l2r
    2436U,	// GETR_rus
    10252U,	// GETSR_lu6
    10252U,	// GETSR_u6
    6334968U,	// GETST_2r
    6334883U,	// GETTS_2r
    6334906U,	// INCT_2r
    62623U,	// INITCP_2r
    70815U,	// INITDP_2r
    79007U,	// INITLR_l2r
    87199U,	// INITPC_2r
    95391U,	// INITSP_2r
    8432212U,	// INPW_l2rus
    7121258U,	// INSHR_2r
    6334955U,	// INT_2r
    6334768U,	// IN_2r
    10528U,	// KCALL_1r
    10528U,	// KCALL_lu6
    10528U,	// KCALL_u6
    10568U,	// KENTSP_lu6
    10568U,	// KENTSP_u6
    10576U,	// KRESTSP_lu6
    10576U,	// KRESTSP_u6
    1446U,	// KRET_0R
    45093065U,	// LADD_l5r
    12585354U,	// LD16S_3r
    12585483U,	// LD8U_3r
    14682170U,	// LDA16B_l3r
    12585018U,	// LDA16F_l3r
    10241U,	// LDAPB_lu10
    10241U,	// LDAPB_u10
    10241U,	// LDAPF_lu10
    10241U,	// LDAPF_lu10_ba
    10241U,	// LDAPF_u10
    14682697U,	// LDAWB_l2rus
    14682697U,	// LDAWB_l3r
    27511U,	// LDAWCP_lu6
    27511U,	// LDAWCP_u6
    100937U,	// LDAWDP_lru6
    100937U,	// LDAWDP_ru6
    12585545U,	// LDAWF_l2rus
    12585545U,	// LDAWF_l3r
    109129U,	// LDAWSP_lru6
    109129U,	// LDAWSP_ru6
    2244U,	// LDC_lru6
    2244U,	// LDC_ru6
    1290U,	// LDET_0R
    186649137U,	// LDIVU_l5r
    1260U,	// LDSED_0R
    1200U,	// LDSPC_0R
    1230U,	// LDSSR_0R
    117327U,	// LDWCP_lru6
    27525U,	// LDWCP_lu10
    117327U,	// LDWCP_ru6
    27525U,	// LDWCP_u10
    100943U,	// LDWDP_lru6
    100943U,	// LDWDP_ru6
    109135U,	// LDWSP_lru6
    109135U,	// LDWSP_ru6
    12585551U,	// LDW_2rus
    12585551U,	// LDW_3r
    270534951U,	// LMUL_l6r
    2099614U,	// LSS_3r
    45093054U,	// LSUB_l5r
    2099756U,	// LSU_3r
    455084433U,	// MACCS_l4r
    455084570U,	// MACCU_l4r
    27601U,	// MJOIN_1r
    2311U,	// MKMSK_2r
    2311U,	// MKMSK_rus
    27546U,	// MSYNC_1r
    2099496U,	// MUL_l3r
    2291U,	// NEG
    2547U,	// NOT
    2099570U,	// OR_3r
    35859U,	// OUTCT_2r
    35859U,	// OUTCT_rus
    78681198U,	// OUTPW_l2rus
    39932U,	// OUTSHR_2r
    35892U,	// OUTT_2r
    35902U,	// OUT_2r
    6334721U,	// PEEK_2r
    2099608U,	// REMS_l3r
    2099745U,	// REMU_l3r
    10561U,	// RETSP_lu6
    10561U,	// RETSP_u6
    35781U,	// SETCLK_l2r
    10264U,	// SETCP_1r
    35761U,	// SETC_l2r
    35761U,	// SETC_lru6
    35761U,	// SETC_ru6
    10273U,	// SETDP_1r
    35771U,	// SETD_2r
    126041U,	// SETEV_1r
    780U,	// SETKEP_0R
    35804U,	// SETN_l2r
    35749U,	// SETPSC_2r
    35984U,	// SETPS_l2r
    35881U,	// SETPT_2r
    35972U,	// SETRDY_l2r
    10282U,	// SETSP_1r
    10621U,	// SETSR_branch_lu6
    10621U,	// SETSR_branch_u6
    10621U,	// SETSR_lu6
    10621U,	// SETSR_u6
    35961U,	// SETTW_l2r
    126052U,	// SETV_1r
    788991U,	// SEXT_2r
    788991U,	// SEXT_rus
    2099483U,	// SHL_2rus
    2099483U,	// SHL_3r
    2099557U,	// SHR_2rus
    2099557U,	// SHR_3r
    1318U,	// SSYNC_0r
    12585025U,	// ST16_l3r
    12585037U,	// ST8_l3r
    1304U,	// STET_0R
    1275U,	// STSED_0R
    1215U,	// STSPC_0R
    1245U,	// STSSR_0R
    100954U,	// STWDP_lru6
    100954U,	// STWDP_ru6
    109146U,	// STWSP_lru6
    109146U,	// STWSP_ru6
    12585562U,	// STW_2rus
    12585562U,	// STW_l3r
    2099391U,	// SUB_2rus
    2099391U,	// SUB_3r
    27622U,	// SYNCR_1r
    6334912U,	// TESTCT_2r
    6334738U,	// TESTLCL_l2r
    6334920U,	// TESTWCT_2r
    3462U,	// TSETMR_2r
    138392U,	// TSETR_3r
    27815U,	// TSTART_1R
    10467U,	// WAITEF_1R
    10715U,	// WAITET_1R
    1451U,	// WAITEU_0R
    2099569U,	// XOR_l3r
    788997U,	// ZEXT_2r
    788997U,	// ZEXT_rus
  };

  // Emit the opcode for the instruction.
  uint32_t Bits = 0;
  Bits |= OpInfo0[MI->getOpcode()] << 0;
  return {AsmStrs+(Bits & 2047)-1, Bits};

}
/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void XCoreInstPrinter::printInstruction(const MCInst *MI, uint64_t Address, raw_ostream &O) {
  O << "\t";

  auto MnemonicInfo = getMnemonic(MI);

  O << MnemonicInfo.first;

  uint32_t Bits = MnemonicInfo.second;
  assert(Bits != 0 && "Cannot print this instruction.");

  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 11) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // DBG_VALUE, DBG_INSTR_REF, DBG_LABEL, BUNDLE, LIFETIME_START, LIFETIME_...
    return;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, EH_RETURN, FRAME_TO_ARGS_OFFSET, LDA...
    printOperand(MI, 0, O);
    break;
  case 2:
    // BR_JT, BR_JT32, CRC8_l4r, INITCP_2r, INITDP_2r, INITLR_l2r, INITPC_2r,...
    printOperand(MI, 1, O);
    break;
  case 3:
    // OUTSHR_2r, TSETR_3r
    printOperand(MI, 2, O);
    break;
  }


  // Fragment 1 encoded into 5 bits for 17 unique commands.
  switch ((Bits >> 13) & 31) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADJCALLSTACKDOWN, EH_RETURN, LDAWFI, LDWFI, STWFI, ADD_2rus, ADD_3r, A...
    O << ", ";
    break;
  case 1:
    // ADJCALLSTACKUP, FRAME_TO_ARGS_OFFSET, BAU_1r, BLAT_lu6, BLAT_u6, BLA_1...
    return;
    break;
  case 2:
    // BR_JT, BR_JT32
    O << "\n";
    break;
  case 3:
    // BLACP_lu10, BLACP_u10, CLRPT_1R, EDU_1r, EEU_1r, FREER_1r, LDAWCP_lu6,...
    O << ']';
    return;
    break;
  case 4:
    // CHKCT_2r, CHKCT_rus, OUTCT_2r, OUTCT_rus, OUTPW_l2rus, OUTSHR_2r, OUTT...
    O << "], ";
    break;
  case 5:
    // EEF_2r, EET_2r, ENDIN_2r, GETD_l2r, GETN_l2r, GETST_2r, GETTS_2r, INCT...
    O << ", res[";
    break;
  case 6:
    // GETPS_l2r
    O << ", ps[";
    printOperand(MI, 1, O);
    O << ']';
    return;
    break;
  case 7:
    // INITCP_2r
    O << "]:cp, ";
    printOperand(MI, 0, O);
    return;
    break;
  case 8:
    // INITDP_2r
    O << "]:dp, ";
    printOperand(MI, 0, O);
    return;
    break;
  case 9:
    // INITLR_l2r
    O << "]:lr, ";
    printOperand(MI, 0, O);
    return;
    break;
  case 10:
    // INITPC_2r
    O << "]:pc, ";
    printOperand(MI, 0, O);
    return;
    break;
  case 11:
    // INITSP_2r
    O << "]:sp, ";
    printOperand(MI, 0, O);
    return;
    break;
  case 12:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp[";
    printOperand(MI, 1, O);
    O << ']';
    return;
    break;
  case 13:
    // LDAWSP_lru6, LDAWSP_ru6, LDWSP_lru6, LDWSP_ru6, STWSP_lru6, STWSP_ru6
    O << ", sp[";
    printOperand(MI, 1, O);
    O << ']';
    return;
    break;
  case 14:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp[";
    printOperand(MI, 1, O);
    O << ']';
    return;
    break;
  case 15:
    // SETEV_1r, SETV_1r
    O << "], r11";
    return;
    break;
  case 16:
    // TSETR_3r
    O << "]:r";
    printOperand(MI, 0, O);
    O << ", ";
    printOperand(MI, 1, O);
    return;
    break;
  }


  // Fragment 2 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 18) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADJCALLSTACKDOWN, EH_RETURN, LDAWFI, LDWFI, STWFI, ADD_2rus, ADD_3r, A...
    printOperand(MI, 1, O);
    break;
  case 1:
    // BR_JT
    printInlineJT(MI, 0, O);
    return;
    break;
  case 2:
    // BR_JT32
    printInlineJT32(MI, 0, O);
    return;
    break;
  case 3:
    // ANDNOT_2r, CRC_l3r, INSHR_2r, SEXT_2r, SEXT_rus, ZEXT_2r, ZEXT_rus
    printOperand(MI, 2, O);
    break;
  case 4:
    // CRC8_l4r, LADD_l5r, LSUB_l5r, OUTPW_l2rus
    printOperand(MI, 0, O);
    O << ", ";
    break;
  }


  // Fragment 3 encoded into 3 bits for 8 unique commands.
  switch ((Bits >> 21) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADJCALLSTACKDOWN, EH_RETURN, LDAWFI, LDWFI, STWFI, ANDNOT_2r, BITREV_l...
    return;
    break;
  case 1:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, CRC_l3r, DIVS_l3r, DIV...
    O << ", ";
    break;
  case 2:
    // CRC8_l4r
    printOperand(MI, 3, O);
    O << ", ";
    printOperand(MI, 4, O);
    return;
    break;
  case 3:
    // EEF_2r, EET_2r, ENDIN_2r, GETD_l2r, GETN_l2r, GETST_2r, GETTS_2r, INCT...
    O << ']';
    return;
    break;
  case 4:
    // INPW_l2rus
    O << "], ";
    printOperand(MI, 2, O);
    return;
    break;
  case 5:
    // LADD_l5r, LSUB_l5r, OUTPW_l2rus
    printOperand(MI, 2, O);
    break;
  case 6:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << '[';
    printOperand(MI, 2, O);
    O << ']';
    return;
    break;
  case 7:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-";
    printOperand(MI, 2, O);
    O << ']';
    return;
    break;
  }


  // Fragment 4 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 24) & 7) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2, O);
    break;
  case 1:
    // CRC_l3r
    printOperand(MI, 3, O);
    return;
    break;
  case 2:
    // LADD_l5r, LSUB_l5r
    O << ", ";
    printOperand(MI, 3, O);
    O << ", ";
    printOperand(MI, 4, O);
    return;
    break;
  case 3:
    // LDIVU_l5r, MACCS_l4r, MACCU_l4r
    printOperand(MI, 4, O);
    O << ", ";
    break;
  case 4:
    // OUTPW_l2rus
    return;
    break;
  }


  // Fragment 5 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 27) & 3) {
  default: llvm_unreachable("Invalid command number.");
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    return;
    break;
  case 1:
    // LDIVU_l5r
    printOperand(MI, 2, O);
    O << ", ";
    printOperand(MI, 3, O);
    return;
    break;
  case 2:
    // LMUL_l6r
    O << ", ";
    printOperand(MI, 3, O);
    O << ", ";
    printOperand(MI, 4, O);
    O << ", ";
    printOperand(MI, 5, O);
    return;
    break;
  case 3:
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 5, O);
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *XCoreInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 17 && "Invalid register number!");


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverlength-strings"
#endif
  static const char AsmStrs[] = {
  /* 0 */ "r10\0"
  /* 4 */ "r0\0"
  /* 7 */ "r11\0"
  /* 11 */ "r1\0"
  /* 14 */ "r2\0"
  /* 17 */ "r3\0"
  /* 20 */ "r4\0"
  /* 23 */ "r5\0"
  /* 26 */ "r6\0"
  /* 29 */ "r7\0"
  /* 32 */ "r8\0"
  /* 35 */ "r9\0"
  /* 38 */ "cp\0"
  /* 41 */ "dp\0"
  /* 44 */ "sp\0"
  /* 47 */ "lr\0"
};
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

  static const uint8_t RegAsmOffset[] = {
    38, 41, 47, 44, 4, 11, 14, 17, 20, 23, 26, 29, 32, 35, 
    0, 7, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool XCoreInstPrinter::printAliasInstr(const MCInst *MI, uint64_t Address, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
